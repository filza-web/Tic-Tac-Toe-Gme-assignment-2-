# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sMzCtXreCpvDirkR2kjNhE_srsfrajn8
"""

class TicTacToe:
    def __init__(self):
        self.board = [' '] * 9
        self.winner = None
        self.visited_nodes = 0

    def show_board(self):
        for row in range(0, 9, 3):
            print('| ' + ' | '.join(self.board[row:row+3]) + ' |')

    def available_moves(self):
        return [i for i, spot in enumerate(self.board) if spot == ' ']

    def has_empty_squares(self):
        return ' ' in self.board

    def make_move(self, position, player):
        if self.board[position] == ' ':
            self.board[position] = player
            if self.check_winner(position, player):
                self.winner = player
            return True
        return False

    def check_winner(self, position, player):
        row_start = (position // 3) * 3
        row = self.board[row_start:row_start + 3]
        if all(spot == player for spot in row):
            return True

        col_start = position % 3
        column = [self.board[col_start + i*3] for i in range(3)]
        if all(spot == player for spot in column):
            return True

        if position % 2 == 0:
            diagonal1 = [self.board[i] for i in [0, 4, 8]]
            diagonal2 = [self.board[i] for i in [2, 4, 6]]
            if all(spot == player for spot in diagonal1) or all(spot == player for spot in diagonal2):
                return True

        return False

def alpha_beta_pruning(game, player, ai_player, alpha, beta):
    game.visited_nodes += 1
    opponent = 'O' if player == 'X' else 'X'

    if game.winner == opponent:
        return {'move': None, 'score': 1 * (len(game.available_moves()) + 1) if opponent == ai_player else -1 * (len(game.available_moves()) + 1)}
    elif not game.has_empty_squares():
        return {'move': None, 'score': 0}

    if player == ai_player:
        best = {'move': None, 'score': float('-inf')}
    else:
        best = {'move': None, 'score': float('inf')}

    for move in game.available_moves():
        game.make_move(move, player)
        simulated = alpha_beta_pruning(game, opponent, ai_player, alpha, beta)
        game.board[move] = ' '
        game.winner = None
        simulated['move'] = move

        if player == ai_player:
            if simulated['score'] > best['score']:
                best = simulated
            alpha = max(alpha, simulated['score'])
        else:
            if simulated['score'] < best['score']:
                best = simulated
            beta = min(beta, simulated['score'])

        if beta <= alpha:
            break

    return best

def play_game():
    print("Welcome to Tic Tac Toe!")

    game = TicTacToe()
    current_player = 'X'

    while game.has_empty_squares():
        if current_player == 'O':
            try:
                move = int(input("Enter your move (0-8): "))
                if move not in game.available_moves():
                    print("Invalid move. Try again.")
                    continue
            except ValueError:
                print("Please enter a number between 0 and 8.")
                continue
        else:
            result = alpha_beta_pruning(game, current_player, current_player, -float('inf'), float('inf'))
            move = result['move']
            print(f"AI chooses move {move}")

        if game.make_move(move, current_player):
            game.show_board()
            print()

            if game.winner:
                print(f"{current_player} wins!")
                return

            current_player = 'O' if current_player == 'X' else 'X'

    print("Game Draw")

if __name__ == '__main__':
    play_game()